# 3D 축구 매치 엔진 아키텍처: \'로또축구단\'을 위한 기술적 타당성 분석 및 구현 전략 보고서

## 1. 서론 (Introduction)

### 1.1 보고서 개요 및 목적

본 기술 보고서는 귀하가 기획 중인 축구 매니지먼트 게임
\*\*\'로또축구단(From Lotto to Legend)\'\*\*의 핵심 코어인 \'매치
엔진(Match Engine)\' 개발을 위한 심층 기술 분석 문서이다. 기존에
검토되었던 \'2D 축구 매치 엔진 개발 가능성 탐색\' 문서는 2D 환경을
가정하고 작성되었으나, 현대 축구 시뮬레이션의 시장 표준과 귀하가 제시한
**\'3D 모델링을 통한 그래픽 구현\'** 및 \*\*\'유니티(Unity) 엔진
사용\'\*\*이라는 요구사항에 맞춰 전면적인 아키텍처 재설계가 필요하다.^1^

본 보고서의 주 목적은 기존 2D 설계의 장점인 \*\*하이브리드 AI 구조(FSM +
Utility AI)\*\*를 계승하면서, 이를 \*\*3D 물리 환경(NVIDIA PhysX)\*\*과
\*\*3차원 공간 추론(Spatial Reasoning)\*\*에 적합하도록 확장 및
고도화하는 것이다. 특히, 단순한 아케이드 게임이 아닌, 선수의
능력치(Stats)와 감독의 라이선스 등급이 경기 결과에 결정적인 영향을
미치는 \'시뮬레이션(Simulation)\' 장르의 특성을 기술적으로 구현하는 데
초점을 맞춘다.

### 1.2 프로젝트의 핵심 기술적 요구사항 (Core Requirements)

제공된 기획 문서(^1^)와 2D 검토 문서(^1^)를 종합 분석한 결과, 본 3D 매치
엔진이 반드시 충족해야 할 기술적 기둥(Pillars)은 다음과 같다.

1.  **완전한 3D 물리 기반 탄도학 (True 3D Ballistics):** 2D 엔진에서
    사용되는 \'가짜 높이(Fake Z-axis)\' 트릭을 폐기하고, 유니티의
    리지드바디(Rigidbody)를 활용하여 공의 질량, 항력(Drag),
    마찰(Friction), 그리고 회전에 의한 \*\*마그누스 효과(Magnus
    Effect)\*\*를 물리적으로 시뮬레이션해야 한다.^3^

2.  **전술적 공간 지능 (Tactical Spatial Intelligence):** AI 에이전트는
    단순한 이동이 아니라, \'하프 스페이스(Half-space)\',
    \'채널(Channel)\', \'포켓(Pocket)\'과 같은 3차원적 전술 개념을
    이해하고 위치를 선정해야 한다.^1^ 이는 유니티의 내비메시(NavMesh)
    시스템과 커스텀 스티어링(Steering) 알고리즘의 결합을 요구한다.

3.  **능력치 기반의 확률적 결정론 (Stat-Driven Determinism):** 게임의
    핵심인 \'로또\' 컨셉에 맞춰, 슈팅 성공률(\$P\_{Goal}\$), 패스
    성공률(\$P\_{Pass}\$), 몸싸움(\$P\_{Duel}\$) 등의 수식이 물리 엔진의
    힘(Force)과 오차(Error Cone)로 정확히 변환되어야 한다.^1^

4.  **라이선스 시스템과의 연동 (License-Dependent AI):** 감독의 라이선스
    등급(무자격\~P급)이 AI의 전술 수행 능력과 판단력에 실시간으로
    가중치(Multiplier)를 부여하는 구조가 아키텍처 레벨에서 통합되어야
    한다.

본 보고서는 이러한 요구사항을 충족하기 위해 **물리 엔진 레이어**, **AI
의사결정 레이어**, **전술 실행 레이어**, **시각화 레이어**로 나누어
상세한 구현 전략을 제시한다.

## 2. 1단계: 3D 물리 엔진 프레임워크 (Phase 1: The 3D Physics Framework)

축구 시뮬레이션의 신뢰성은 \'공이 얼마나 리얼하게 움직이는가\'와
\'선수들이 얼마나 물리적으로 상호작용하는가\'에 달려 있다. 유니티의
PhysX 엔진을 기반으로 하되, 축구 특화 물리 로직을
오버라이드(Override)하는 방식이 필요하다.

### 2.1 공(Ball)의 3D 물리 구현

2D 설계안에서 제안된 \'스케일 조절을 통한 높이 착시\'^1^는 3D 환경에서는
불필요하며 오히려 시각적 괴리를 유발한다. 따라서 SphereCollider와
Rigidbody 컴포넌트를 기반으로 한 순수 3D 물리 모델을 구축해야 한다.

#### 2.1.1 리지드바디(Rigidbody) 설정 및 튜닝

FIFA 규격 축구공의 물리적 특성을 유니티 물리 엔진에 매핑하기 위해서는
정교한 파라미터 튜닝이 필수적이다. 기본값 사용 시 공이 풍선처럼
날아가거나 볼링공처럼 무겁게 느껴질 수 있다.

  ------------------- ----------------- ------------------------------- -----------------
  **속성 (Property)** **권장 설정값     **물리적 근거 및 효과**         **참조 문서**
                      (Recommended                                      
                      Value)**                                          

  **Mass (질량)**     **0.41 \~ 0.45    FIFA 공인구 규격 질량. 물리     ^4^
                      kg**              충돌 시 \$F=ma\$ 계산의 기준이  
                                        됨.                             

  **Drag (선형        **0.4 \~ 0.6**    공기 저항 계수. 0일 경우 공이   ^1^
  항력)**                               감속 없이 영원히 날아감. 슈팅의 
                                        거리별                          
                                        감쇠(\$Distance\_{decay}\$)를   
                                        자연스럽게 구현함.              

  **Angular Drag      **0.5 \~ 1.0**    공의 회전 감쇠율. 너무 낮으면   ^7^
  (회전 항력)**                         공이 지면에서도 계속 헛돔.      
                                        적절한 값은 마그누스 효과의     
                                        지속 시간을 결정함.             

  **Collision         **Continuous      고속으로 날아가는 공이 골대나   ^8^
  Detection**         Dynamic**         선수(MeshCollider)를 뚫고       
                                        지나가는 터널링(Tunneling) 현상 
                                        방지.                           

  **Interpolation**   **Interpolate**   물리 업데이트(FixedUpdate)와    ^8^
                                        렌더링 프레임(Update) 간의      
                                        불일치로 인한 공의 떨림(Jitter) 
                                        보정.                           
  ------------------- ----------------- ------------------------------- -----------------

#### 2.1.2 마그누스 효과(Magnus Effect)의 구현

\'로또축구단\'의 기술 능력치 중 \*\*\'킥(Kick)\'\*\*이나
**\'슈팅(Shooting)\'** 능력치가 높은 선수가 감아차기(Curved Shot)를
구사할 때, 3D 공간에서 공이 휘어지는 궤적을 그리려면 유니티 기본 물리
엔진만으로는 부족하다. 유니티는 유체 역학(Fluid Dynamics)을 기본
제공하지 않으므로, 스크립트를 통해 \*\*마그누스 힘(Magnus Force)\*\*을
인위적으로 가해야 한다.

물리 공식의 코드화:

마그누스 힘 \$\\mathbf{F}\_m\$은 각속도 벡터(\$\\mathbf{\\omega}\$)와
선속도 벡터(\$\\mathbf{v}\$)의 외적(Cross Product)에 비례한다.

\$\$\\mathbf{F}\_m = S\_{lift} \\cdot (\\mathbf{\\omega} \\times
\\mathbf{v})\$\$

여기서 \$S\_{lift}\$는 공기 밀도와 공의 단면적, 회전 효율을 포함한 양력
계수이다. 이를 BallAerodynamics.cs 스크립트로 구현한다.

> C#

// BallAerodynamics.cs 예시 로직\
public float magnusCoefficient = 0.002f; // 게임 밸런스에 맞춰 조정\
\
void FixedUpdate() {\
Rigidbody rb = GetComponent\<Rigidbody\>();\
\
// 각속도(Spin)와 선속도(Velocity)의 외적을 통해 휘어지는 힘의 방향과
크기 계산\
Vector3 magnusForce = Vector3.Cross(rb.angularVelocity, rb.velocity);\
\
// 리지드바디에 힘 적용 (ForceMode.Force는 질량을 고려함)\
rb.AddForce(magnusForce \* magnusCoefficient, ForceMode.Force);\
}

이 로직을 통해 **\'기술\'** 능력치가 높은 선수가 공에 높은 AddTorque를
가하면, 공은 물리적으로 자연스럽게 휘어져 골문 구석으로 빨려 들어가는
궤적을 그리게 된다. 이는 2D에서는 불가능한 시각적, 전술적 깊이를
제공한다.^3^

#### 2.1.3 지면 마찰과 바운스 (PhysicMaterial)

공이 잔디 위에서 구르거나 튀길 때의 반응은 PhysicMaterial을 통해
제어한다.

- **잔디 (Grass Material):** Bounciness 0.1, Dynamic Friction 0.6,
  Static Friction 0.7.

- **공 (Ball Material):** Bounciness 0.7.

- **조합 방식 (Combine Mode):** 마찰은 Multiply 또는 Average를 사용하여
  잔디의 저항력이 공에 확실히 전달되도록 하고, 반발력은 Maximum을 피하여
  공이 비현실적으로 높이 튀는 것을 방지한다.^9^

### 2.2 선수 이동 메커니즘: 하이브리드 내비게이션 (Hybrid Navigation)

축구 게임에서 AI의 이동은 딜레마가 있다. 유니티의 NavMeshAgent는 길
찾기(Pathfinding)에는 탁월하지만, 물리적인 충돌(몸싸움)을 무시하거나
밀림 현상이 어색하다. 반면 Rigidbody 이동은 물리 반응은 좋으나 정교한
경로 추적에 약하다.

\'로또축구단\'은 \'몸싸움(\$P\_{Duel}\$)\' 능력치1가 이동에 영향을 줘야
하므로, 이 두 가지를 결합한 하이브리드 방식을 제안한다.11

**하이브리드 구현 아키텍처:**

1.  **두뇌 (Brain - NavMeshAgent):** NavMeshAgent 컴포넌트를 사용하여
    목적지까지의 경로를 계산한다. 단, agent.updatePosition = false,
    agent.updateRotation = false로 설정하여 에이전트가 실제로 트랜스폼을
    움직이지 않게 한다.

2.  **신체 (Body - Rigidbody):** 실제 이동은 Rigidbody를 통해 수행한다.
    매 FixedUpdate마다 NavMeshAgent가 계산한 \'다음 목표
    지점(nextPosition)\'을 향해 물리적인 힘(AddForce)이나
    속도(velocity)를 적용한다.

**이점:**

- 선수가 다른 선수와 충돌할 때 물리 엔진이 작동하여 자연스럽게
  밀려나거나 넘어지는 연출이 가능하다.

- **\'피지컬(Strength)\'** 스탯이 높은 선수는 충돌 시 Rigidbody 질량이나
  힘의 우위를 통해 상대 수비수를 밀어내며 경로를 유지할 수 있다. 이는
  \$P\_{Duel}\$ 공식을 물리적으로 시각화하는 핵심이다.^1^

## 3. 2단계: AI 아키텍처 - 하이브리드 지능 시스템 (Phase 2: The AI Architecture)

2D 보고서^1^에서 제안된 **HFSM(계층적 유한 상태 머신) + Utility AI**
구조는 3D 환경에서도 여전히 가장 유효한 접근법이다. 다만, 3D 공간 정보와
\'로또축구단\' 고유의 라이선스 시스템을 반영하여 구조를 구체화해야 한다.

### 3.1 계층적 유한 상태 머신 (HFSM): 문맥(Context) 관리

HFSM은 선수가 현재 처한 거시적인 상황(State)을 정의한다. 선수는 한 번에
하나의 상위 상태에 속하며, 그 내부에서 하위 상태를 가진다.

**상위 상태 (Root States) 정의:**

1.  **공격 (Attacking - In Possession):** 팀이 공을 소유함.

    - *하위 상태:* 빌드업(Build-up), 전개(Progression),
      마무리(Finishing).^1^

2.  **수비 (Defending - Out of Possession):** 상대가 공을 소유함.

    - *하위 상태:* 로우 블록(Low Block), 미들 블록(Mid Block), 하이
      블록(High Block), 압박(Pressing).

3.  **전환 (Transition):** 공수 교대 순간.

    - *하위 상태:* 역압박(Counter-Press), 재정비(Regroup/Recovery).

4.  **세트피스 (Set-Piece):** 코너킥, 프리킥, 페널티킥.

**상태 전이(Transition) 예시:**

- IF (우리 팀이 공을 뺏김) AND (전술 지침 == \'즉시
  압박(Counter-Press)\') \$\\rightarrow\$ **State:
  Transition_CounterPress**.

- IF (우리 팀이 공을 뺏김) AND (전술 지침 == \'재정비(Regroup)\')
  \$\\rightarrow\$ **State: Transition_Recovery** (자신의 수비 위치로
  복귀).

### 3.2 유틸리티 AI (Utility AI): 미시적 의사결정

HFSM이 \"무엇을 해야 하는 상황인가\"를 정해준다면, 유틸리티 AI는
\"구체적으로 어떤 행동을 할 것인가\"를 점수(Score) 기반으로 결정한다.
여기서 **\'로또\' 스탯**들이 결정적인 가중치(Weight)로 작용한다.^1^

행동 점수 산출 공식 (Scoring Function):

\$\$\\text{Score}(Action) = \\sum (\\text{Factor}\_i \\times
\\text{Weight}\_i) \\times \\text{LicenseModifier}\$\$

**주요 행동별 평가 로직 (3D 환경 적용):**

1.  **행동: 슛 (Shoot)**

    - *입력 변수:* 골대와의 거리(Vector3.Distance), 슈팅 각도(Dot
      Product), 전방 수비수 밀집도(Physics.OverlapSphere), 선수의
      **결정력(Finishing)** 및 **침착성(Composure)** 스탯.

    - *특수 로직:* 플레이어 특성 \'중거리 슛 선호\' 보유 시 거리 페널티
      감소.

2.  **행동: 패스 (Pass)**

    - *입력 변수:* 동료의 오픈 상태(Raycast를 통한 시야선 확보 여부),
      선수의 **시야(Vision)** 및 **패스(Passing)** 스탯.

    - *특수 로직:* 감독 라이선스가 높을수록(P급) \'전술적 지시(예: 짧은
      패스)\'에 부합하는 행동에 가산점 부여.

3.  **행동: 드리블 (Dribble)**

    - *입력 변수:* 전방 공간의 크기(NavMesh 탐색), 선수의
      **드리블(Dribbling)** 및 **속도(Speed)** 스탯.

### 3.3 지시 불이행 (Instruction Non-Compliance) 시스템 구현

귀하의 기획 의도 중 가장 중요한 \'인간적 결함\'과 \'지시 불이행\'은
**규율 체크(Discipline Check)** 모듈을 통해 구현한다.^1^

- **발동 조건:** 선수의 **\'정신(Mental)\'** 능력치 중
  \*\*집중력(Concentration)\*\*이나 \*\*판단력(Judgment)\*\*이 낮거나,
  \*\*체력(Stamina)\*\*이 고갈되어 \'상태 지수\'가 떨어질 때.^1^

- **구현 로직:**\
  C#\
  // 의사결정 루프 내부\
  bool isDisciplined = Random.value \< (player.MentalStats.Concentration
  \* fatigueFactor);\
  \
  if (!isDisciplined) {\
  // 지시 불이행 발생: 감독이 \'패스\'를 지시했으나, \'탐욕\' 특성이
  발동하여 낮은 확률의 \'슛\'을 선택\
  utilityScorer.BoostAction(\"Shoot\", 2.0f); // 슛 점수 강제 2배
  뻥튀기\
  Debug.Log(player.name + \" ignored tactics due to low
  concentration!\");\
  }\
  \
  이 시스템은 유저로 하여금 선수 교체나 훈련의 필요성을 체감하게 만드는
  핵심 메커니즘이 된다.

## 4. 3단계: 전술적 이동과 포메이션 (Phase 3: Tactical Movement & Positioning)

3D 공간에서의 전술 구현은 2D보다 복잡하다. 기획 문서^1^에 명시된 상세한
역할(Role)들을 3차원 벡터 연산으로 변환해야 한다.

### 4.1 동적 포메이션 시스템 (Dynamic Formation System)

선수들은 고정된 좌표에 서 있는 것이 아니라, 공의 위치(Ball Position)에
따라 유기적으로 이동해야 한다. 이를 위해 \*\*상대적 좌표계(Relative
Coordinates)\*\*를 사용한다.

- **앵커 포인트(Anchor Point):** 각 포메이션(4-3-3, 4-4-2 등)은 기본
  위치 벡터를 가진다.

- **공의 영향력(Ball Influence):** 공이 좌측으로 이동하면, 팀 전체의
  대형이 좌측으로 Lerp(선형 보간) 이동한다.

- **Z축 압축/이완:** 수비 시에는 라인 간격(Z축 거리)을
  좁히고(Compactness), 공격 시에는 넓혀 공간을 확보한다.

### 4.2 역할별 3D 이동 로직 (Role-Specific Logic)

^1^

#### A. 인버티드 윙백 (Inverted Wingback)

- **기존 2D:** 단순히 중앙 쪽 좌표로 이동.

- **3D 구현:** 공격 시(In Possession), 터치라인을 타고 올라가는 것이
  아니라, 중앙 미드필더(DM/CM) 라인의 빈 공간(Pocket)을 탐색한다.

  - TargetPos = new Vector3(Mathf.Lerp(CurrentX, 0, 0.7f), 0,
    DM_Line_Z);

  - 이동 시 NavMesh 상의 코스트를 계산하여 중앙 밀집 지역을 우회하거나
    돌파한다.

#### B. 하프백 (Half-back DM)

- **로직:** 빌드업 시 두 센터백(CB) 사이가 벌어지면, 그 사이 공간으로
  후퇴하여 3백(Back-3)을 형성한다.

  - TargetPos = Vector3.Lerp(CB_Left.position, CB_Right.position,
    0.5f) - Vector3.forward \* 2.0f;

#### C. 채널 미드필더 (Channel CM)

- **로직:** 상대편 센터백(CB)과 풀백(FB) 사이의 공간(Channel)을
  Raycast로 탐지하고, 해당 공간으로 침투(Run) 벡터를 생성한다.

### 4.3 라이선스에 따른 전술 제한 구현

감독 라이선스 시스템은 플레이어의 선택지를 제한하는 필터로 작동한다.

- **무자격 감독:** 4-4-2, 4-3-3 포메이션만 선택 가능. 세부 전술
  슬라이더(예: 압박 강도, 라인 높이)가 비활성화되거나 기본값으로 고정됨.

- **P급 감독:** 모든 포메이션 해금 및 \'인버티드 윙백\' 같은 복합
  역할(Role) 사용 가능.

## 5. 4단계: 핵심 게임플레이 메커니즘 구현 (Phase 4: Core Mechanics Implementation)

능력치 산출 공식 문서^1^에 명시된 수식을 실제 유니티 C# 코드로 변환하는
과정이다.

### 5.1 슈팅 메커니즘 (\$P\_{Goal}\$)

슈팅은 **(1) 퀄리티 계산**과 **(2) 물리적 실행**으로 나뉜다.

\*\* 퀄리티 계산 (\$Q\_{shot}\$ 구현)\*\*

> C#

public float CalculateShotQuality(PlayerStats shooter, float
distanceToGoal, float pressure) {\
// 1. 기본 정확도 및 침착성 반영\
float baseQuality = (shooter.Shooting \* 0.6f) + (shooter.Composure \*
0.4f);\
\
// 2. 약발(Weak Foot) 보정\
if (shooter.IsUsingWeakFoot) {\
baseQuality \*= (shooter.WeakFootRating \* 0.1f); // 예: 약발 3 -\>
0.3배\
}\
\
// 3. 거리 감쇠 (Distance Decay) - 문서 공식 적용\
float distanceDecay = 1.0f;\
if (distanceToGoal \> 10f && distanceToGoal \<= 25f) {\
distanceDecay = 1.0f - ((distanceToGoal - 10f) \* 0.03f); // 선형 감쇠\
} else if (distanceToGoal \> 25f) {\
distanceDecay = Mathf.Exp(-(distanceToGoal - 25f) \* 0.1f); // 지수
감쇠\
}\
\
// 4. 압박 보정 (분모가 0이 되지 않도록 Mathf.Max 사용)\
float finalQuality = baseQuality / (Mathf.Max(distanceDecay, 0.1f) \*
Mathf.Max(pressure, 1.0f));\
\
return finalQuality;\
}

\*\* 물리적 실행 (오차 원뿔 - Error Cone)\*\*

계산된 finalQuality가 낮을수록 공이 날아가는 벡터에 무작위
노이즈(오차)를 더한다.

- **목표 지점:** 골대 내부의 랜덤한 점.

- **오차 적용:** Quaternion.Euler(Random.Range(-error, error),
  Random.Range(-error, error), 0) \* directionVector.

- **결과:** 낮은 능력치의 선수가 슛을 하면 물리적으로 공이 골대를 크게
  벗어나거나, 빗맞아서 약하게 굴러가는 현상이 **시각적, 물리적으로
  자연스럽게** 연출된다.^13^

### 5.2 패스 및 퍼스트 터치 (\$P\_{Pass}\$)

패스는 \'보내는 사람\'의 정확도와 \'받는 사람\'의 트래핑 능력의
결합이다.

- **패스 실행:** 거리 가중치를 적용한 성공률 공식에 따라 패스 벡터의
  정확도가 결정된다.

- **트래핑 판정 (Trapping Check):** 공이 받는 선수의 Collider에 닿는
  순간(OnCollisionEnter), 선수의 **\'퍼스트 터치(First Touch)\'** 스탯을
  체크한다.

  - *성공 시:* 공의 속도(velocity)를 대폭 감쇠시키고(\* 0.1), 공을 선수
    발 앞에 붙여둔다(드리블 상태 전환).

  - *실패 시(튀김):* 공이 선수 몸에 맞고 튕겨 나간다(AddForce로 랜덤
    방향 반사). 이때 주변 선수들의 **\'적극성(Aggression)\'** 스탯에
    기반한 루즈볼 경합(Re-duel) 로직이 발동된다.^1^

### 5.3 호흡(Breath)과 체력 시스템

\'로또축구단\'의 독창적인 시스템인 \*\*\'호흡\'\*\*은 단기 스프린트를
제한한다.^1^

- **구현:** Rigidbody의 속도가 일정 수준(스프린트 임계값)을 넘으면
  CurrentBreath 게이지가 급격히 감소한다.

- **제약:** CurrentBreath가 0이 되면, 유틸리티 AI는 \'스프린트\' 행동을
  선택지에서 제외하고 강제로 \'걷기\'나 \'조깅\' 상태로 전환한다. 이는
  유저가 선수 교체 타이밍을 잡는 전략적 지표가 된다.

## 6. 5단계: 시각화 및 피드백 (Phase 5: Visuals & Feedback)

3D 엔진의 장점은 시각적 피드백이다. 물리 시뮬레이션 결과를 유저에게
납득시켜야 한다.

### 6.1 애니메이션과 물리 동기화 (Animation Sync)

단순히 애니메이션을 재생하는 것이 아니라, 애니메이션의 발이 공에 닿는
순간에 물리 힘이 가해져야 한다.

- **애니메이션 이벤트(Animation Events):** 킥 애니메이션의 임팩트
  프레임에 ApplyKickForce() 이벤트를 삽입한다.

- **기대 효과:** 발이 공에 닿기도 전에 공이 날아가는 \'슬라이딩\' 현상을
  방지하고, 타격감 있는 슛 장면을 연출한다.^15^

### 6.2 3D 전술 UI

- **전술 보드:** 3D 경기장 위에 오버레이(Overlay)되는 전술 라인(패스 길,
  수비 블록 범위)을 시각화하여, \"내가 내린 전술이 어떻게 돌아가는지\"를
  직관적으로 보여준다.

- **중계 자막 시스템:** 물리 엔진의 이벤트(골, 파울, 선방)를 감지하여
  \"GOAL FOR MANCHESTER CITY!!\"와 같은 텍스트를 실시간으로 출력한다.

## 7. 결론 및 로드맵 (Conclusion & Roadmap)

### 7.1 타당성 분석 결론

\'로또축구단\'의 3D 매치 엔진 개발은 **기술적으로 충분히 타당하며, 기획
의도를 구현하기 위해 필수적**이다.

- **물리적 리얼리티:** 유니티 PhysX와 마그누스 효과 구현을 통해 2D에서는
  불가능한 탄도학과 볼 컨트롤의 디테일을 살릴 수 있다.

- **전술적 깊이:** 3D 좌표계를 활용한 공간 분할(하프 스페이스, 채널)은
  현대 축구 전술 구현에 최적화되어 있다.

- **게임성 강화:** 확률 수식(\$P\_{Goal}\$)을 물리 오차(Error Cone)로
  변환함으로써, 수치상의 확률이 실제 눈앞의 \'실수\'나 \'슈퍼 플레이\'로
  시각화되어 \"로또\"와 같은 드라마틱한 결과를 만들어낸다.

### 7.2 개발 로드맵 제안

본 보고서는 다음과 같은 단계적 개발을 권장한다.

1.  **M1 (기반 구축):** 유니티 3D 물리 환경 설정 (공 리지드바디 튜닝,
    마그누스 효과 스크립트 작성).

2.  **M2 (이동 구현):** NavMesh와 Rigidbody를 결합한 하이브리드 이동
    시스템 구축.

3.  **M3 (AI 두뇌):** HFSM 상태 머신 설계 및 포지션별 기본 역할(Role)
    로직 구현.

4.  **M4 (능력치 연동):** \$P\_{Goal}, P\_{Pass}\$ 등 확률 공식을 물리
    엔진(AddForce 오차)에 연동. 라이선스 제한 시스템 적용.

5.  **M5 (전술 고도화):** 호흡/체력 시스템 및 오프더볼 움직임 구현. 3D
    애니메이션 싱크 작업.

이 아키텍처는 1인 개발자가 관리 가능한 모듈성을 유지하면서도,
FM(풋볼매니저)류 게임이 추구하는 깊이 있는 시뮬레이션을 3D로 구현할 수
있는 가장 확실한 방법론이다.

#### 참고 자료

1.  2D 축구 매치 엔진 개발 가능성 탐색.pdf

2.  2D and 3D mode settings - Unity - Manual, 1월 10, 2026에 액세스,
    [[https://docs.unity3d.com/6000.3/Documentation/Manual/2DAnd3DModeSettings.html]{.underline}](https://docs.unity3d.com/6000.3/Documentation/Manual/2DAnd3DModeSettings.html)

3.  Calculating Angular Velocity Needed to Travel a Certain Distance Via
    the Magnus Effect, 1월 10, 2026에 액세스,
    [[https://stackoverflow.com/questions/53244613/calculating-angular-velocity-needed-to-travel-a-certain-distance-via-the-magnus]{.underline}](https://stackoverflow.com/questions/53244613/calculating-angular-velocity-needed-to-travel-a-certain-distance-via-the-magnus)

4.  Rigidbody - Unity - Manual, 1월 10, 2026에 액세스,
    [[https://docs.unity3d.com/2020.1/Documentation/Manual/class-Rigidbody.html]{.underline}](https://docs.unity3d.com/2020.1/Documentation/Manual/class-Rigidbody.html)

5.  UnityVR, Adjusting the Physics of Balls \| by Austin Young - Medium,
    1월 10, 2026에 액세스,
    [[https://medium.com/@austinjy13/unityvr-adjusting-the-physics-of-balls-318caab48c8d]{.underline}](https://medium.com/@austinjy13/unityvr-adjusting-the-physics-of-balls-318caab48c8d)

6.  Rigidbody Drag - Unity in 1 minute - YouTube, 1월 10, 2026에 액세스,
    [[https://www.youtube.com/watch?v=PTUEXaSob50]{.underline}](https://www.youtube.com/watch?v=PTUEXaSob50)

7.  Rigidbody Angular Drag - Unity in 1 minute - YouTube, 1월 10, 2026에
    액세스,
    [[https://www.youtube.com/watch?v=Gn40IWvrKvk]{.underline}](https://www.youtube.com/watch?v=Gn40IWvrKvk)

8.  Physics Objects (Rigidbodies) - Unity Official Tutorials - YouTube,
    1월 10, 2026에 액세스,
    [[https://www.youtube.com/watch?v=WTGcs10Sj34]{.underline}](https://www.youtube.com/watch?v=WTGcs10Sj34)

9.  Physic Material - Dynamic Friction - Unity - Manual, 1월 10, 2026에
    액세스,
    [[https://docs.unity3d.com/520/Documentation/Manual/class-PhysicMaterial.html]{.underline}](https://docs.unity3d.com/520/Documentation/Manual/class-PhysicMaterial.html)

10. Creating an Infinite Bouncing Ball with Physic Materials (Unity
    Tutorial) - YouTube, 1월 10, 2026에 액세스,
    [[https://www.youtube.com/watch?v=ZOxnizAvMys]{.underline}](https://www.youtube.com/watch?v=ZOxnizAvMys)

11. Using NavMesh with 3D Physics in Unity : r/Unity3D - Reddit, 1월 10,
    2026에 액세스,
    [[https://www.reddit.com/r/Unity3D/comments/1hptmxv/using_navmesh_with_3d_physics_in_unity/]{.underline}](https://www.reddit.com/r/Unity3D/comments/1hptmxv/using_navmesh_with_3d_physics_in_unity/)

12. custom rigidbody navmesh agent with physics based jumping and
    off-mesh obstacle avoidance : r/Unity3D - Reddit, 1월 10, 2026에
    액세스,
    [[https://www.reddit.com/r/Unity3D/comments/1myhn31/custom_rigidbody_navmesh_agent_with_physics_based/]{.underline}](https://www.reddit.com/r/Unity3D/comments/1myhn31/custom_rigidbody_navmesh_agent_with_physics_based/)

13. im trying to add accuracy to my 2d top down game and it doesn\'t
    work. this is the code I tried if someone has an idea how to make it
    work plz type in the comments : r/Unity2D - Reddit, 1월 10, 2026에
    액세스,
    [[https://www.reddit.com/r/Unity2D/comments/wpr9bf/im_trying_to_add_accuracy_to_my_2d_top_down_game/]{.underline}](https://www.reddit.com/r/Unity2D/comments/wpr9bf/im_trying_to_add_accuracy_to_my_2d_top_down_game/)

14. Hit Moving Targets with Projectiles \| AI Series Part 41 \| Unity
    Tutorial - YouTube, 1월 10, 2026에 액세스,
    [[https://www.youtube.com/watch?v=6YsamZNNwpQ]{.underline}](https://www.youtube.com/watch?v=6YsamZNNwpQ)

15. Unity - Animation-synced movement \| James Hardy, 1월 10, 2026에
    액세스,
    [[https://games-hardy.com/posts/unity-animation-syncing/]{.underline}](https://games-hardy.com/posts/unity-animation-syncing/)

16. How do you guys sync up the hit animation with the actual hit? :
    r/gamedev - Reddit, 1월 10, 2026에 액세스,
    [[https://www.reddit.com/r/gamedev/comments/vbgu1a/how_do_you_guys_sync_up_the_hit_animation_with/]{.underline}](https://www.reddit.com/r/gamedev/comments/vbgu1a/how_do_you_guys_sync_up_the_hit_animation_with/)
